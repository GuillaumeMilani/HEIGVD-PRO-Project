\section{Conclusion}
Le programme fourni connaît certains problèmes de performances dû aux choix d'implémentation effectués. La taille des sauvegardes même après compression reste grande, ce qui implique que notre façon de garder un historique des changements est gourmand. Après chaque changement, on effectue une sauvegarde intégrale de l'espace de travail pour qu'il puisse être restauré par la suite. Ainsi, si l'on travaille sur des grandes images, on peut voir apparaître un délai après chaque action ou chaque utilisation d'un Ctrl + Z. En plus de ces ralentissements, la quantité de mémoire utilisée peut s'avérer problématique.

À notre avis, ceci est le plus grand défaut de notre application. Pour corriger ceci, l'implémentation de l'historique aurait pu être effectuée différemment: pour chaque action effectuée, il aurait été possible de sauvegarder un objet permettant d'effectuer l'action inverse. Par exemple, pour une symétrie horizontale, une implémentation possible aurait été d'empiler sur l'historique un objet effectuant une autre symétrie horizontale. Avec cette façon de faire, on évite de sauvegarder l'intégralité de l'espace de travail et on ne stocke qu'un objet très petit. Le problème de cette implémentation est sa difficulté d'implémentation. Pour chaque transformation, il doit être possible de coder son inverse et stocker les calques sur lesquelles il à été effectué. Avec un grand nombre d'actions possibles dans le programme cela représente une charge de travail considérable et, bien que plus performant, le temps nécessaire à son implémentation n'était simplement pas disponible.

Certaines améliorations du programme pourraient être effectuées. Notamment les fonctionnalités optionnelles que nous n'avons pas eu le temps d'implémenter. Par exemple, pouvoir paramétrer l'interface pour placer les outils, l'historique et l'affichage des calques à des endroits différents ou encore les cacher. Une autre fonctionnalité aurait été l'importation d'une collection d'images personnalisée pouvant être affiché dans l'interface et qui, avec un glisser-déposer, permettrait d'ajouter plus rapidement des images à un projet. Cette partie de l'interface pourrait contenir des images prédéfinies, comme des émoticônes susceptibles d'être ajoutés à un document. De manière générale, plus d'outils pourraient être ajoutés comme la sélection automatique, la sélection de forme quelconque, le pot de peinture ou plus d'outils de dessin. Avec l'interface modulaire de notre application, ajouter des outils à celle-ci est simple et ne risque pas de casser la mise en forme.

Pour ce qui concerne le travail de groupe, il a été difficile au début du projet de répartir des tâches pouvant être effectuées individuellement. Vu que le programme est composé entièrement d'une unique interface graphique, il existe beaucoup de dépendances entre les fonctionnalités. Travailler sans se marcher dessus et sans devoir attendre des fonctionnalités n'a pas toujours été facile. Notre planification des tâche initiale à cependant pris en compte ces dépendances et l'ordre d'implémentation des fonctionnalités à permis, dès l'élaboration de l'interface principale, d'éviter la plus part des conflits. Cependant, il s'est de temps en temps avéré qu'un changement de l'un des membres du groupe affecte les outils d'autres membres, notamment en ce qui concerne les systèmes de coordonnées.

Au final, le programme réalisé nous semble correspondre au cahier des charges proposé et, malgré certains problèmes de performance, est un outil qui nous restera utile en dehors du cadre de ce cours.
